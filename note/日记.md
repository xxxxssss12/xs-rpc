# 日记

## 前言

突然想记一下踩过的坑。

已经踩过的如下

1. 数据协议定义，传输工具选择
2. 元数据定义
3. 消费者配置确定
4. 提供者配置确定

还有很多坑，没有深入思考

1. 服务提供方怎么启动？怎么挂起？启动要哪些步骤？
2. 消费方怎么启动？
3. 这个rpc框架别人怎么用？消费者/提供者怎么定义？外部怎么启动？配置文件用xml?properties?yml?外部代码可否直接声明消费者和提供者？

## 20191213

今天碰到的坑在返回数据内容上。

Result接口定义2个属性，一个data，一个exception

data好说，直接用json序列化即可

exception怎么序列化？消费者收到异常怎么捕获？

dubbo应该是用hessian对exception进行的序列化。

做了个实验看toString 和 hessian序列化后的字节数
```java
public static void main(String [] args) {

    IOException obj = new IOException();
    // 序列化
    byte[] serialize = serialize(obj);
    Constant.LOG.info("serialize.length={}", serialize.length);
    // 反序列化
    obj = (IOException) deserialize(serialize);
    String s = getErrorInfoFromException(obj);
    log.info(s);
    Constant.LOG.info("error2Str.length={}", s.getBytes().length);
}
public static String getErrorInfoFromException(Throwable e) {
    try (StringWriter sw = new StringWriter()){
        try (PrintWriter pw = new PrintWriter(sw)) {
            e.printStackTrace(pw);
            return "\r\n" + sw.toString() + "\r\n";
        } catch (Exception e1) {
            e.printStackTrace();
        }
    } catch (Exception e2) {
        e.printStackTrace();
    }
    return null;
}
```

输出结果:

```
# 栈深度=1
serialize.length=333
error2Str.length=94
# 栈深度=50
serialize.length=8933
error2Str.length=4294
```

这样会有三个问题

一是，字节会变多，序列化后数据不可阅读。

二是，消费方如果没有这个类，是无法进行反序列化的，会抛出反序列化异常。

三是，需要依赖hessian，增加了框架依赖

那么这个异常，还有更优雅的处理方式么？

我想了一个：
1. 定义XsRpcExceptionSerialize类，其中三个属性:
    1. className
    2. message (throwable均有message)
    3. (消费者不需要)stacktrace (string类型，栈之间用逗号分割)(sw.toString().replaceAll(System.getProperty("line.separator"), ",").replaceAll("\\t", ""))
2. 如果有异常信息，转成这个对象返回消费者方
3. 消费者方收到该异常后，直接抛出XsRpcException,message展示该对象内容。