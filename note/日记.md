# 日记

## 前言

突然想记一下踩过的坑。

已经踩过的如下

1. 数据协议定义，传输工具选择
2. 元数据定义
3. 消费者配置确定
4. 提供者配置确定

还有很多坑，没有深入思考

1. 服务提供方怎么启动？怎么挂起？启动要哪些步骤？
2. 消费方怎么启动？
3. 这个rpc框架别人怎么用？消费者/提供者怎么定义？外部怎么启动？配置文件用xml?properties?yml?外部代码可否直接声明消费者和提供者？

## 20191213

今天碰到的坑在返回数据内容上。

Result接口定义2个属性，一个data，一个exception

data好说，直接用json序列化即可

exception怎么序列化？消费者收到异常怎么捕获？

dubbo应该是用hessian对exception进行的序列化。

做了个实验看toString 和 hessian序列化后的字节数
```java
public static void main(String [] args) {

    IOException obj = new IOException();
    // 序列化
    byte[] serialize = serialize(obj);
    Constant.LOG.info("serialize.length={}", serialize.length);
    // 反序列化
    obj = (IOException) deserialize(serialize);
    String s = getErrorInfoFromException(obj);
    log.info(s);
    Constant.LOG.info("error2Str.length={}", s.getBytes().length);
}
public static String getErrorInfoFromException(Throwable e) {
    try (StringWriter sw = new StringWriter()){
        try (PrintWriter pw = new PrintWriter(sw)) {
            e.printStackTrace(pw);
            return "\r\n" + sw.toString() + "\r\n";
        } catch (Exception e1) {
            e.printStackTrace();
        }
    } catch (Exception e2) {
        e.printStackTrace();
    }
    return null;
}
```

输出结果:

```
# 栈深度=1
serialize.length=333
error2Str.length=94
# 栈深度=50
serialize.length=8933
error2Str.length=4294
```

这样会有三个问题

一是，字节会变多，序列化后数据不可阅读。

二是，消费方如果没有这个类，是无法进行反序列化的，会抛出反序列化异常。

三是，需要依赖hessian，增加了框架依赖

那么这个异常，还有更优雅的处理方式么？

我想了一个：
1. 定义 XsRpcExceptionSerialize 类，其中三个属性:
    1. className
    2. message (throwable均有message)
    3. (消费者不需要)stacktrace (string类型，栈之间用逗号分割)(sw.toString().replaceAll(System.getProperty("line.separator"), ",").replaceAll("\\t", ""))
2. 如果有异常信息，转成这个对象返回消费者方
3. 消费者方收到该异常后，直接抛出XsRpcException,message展示该对象内容。

## 20200110

拖啊拖拖啊拖

今天开始写服务提供方处理逻辑

发现我定义了result，即方法返回值，但是没有定义request，即方法入参

所以我再次打开了dubbo，学习dubbo的入参定义

找到dubbo的NettyServerHandler，顺着代码找到org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol，其中的requestHandler#received方法中，
有一个（message instanceof Invocation），于是找到了org.apache.dubbo.rpc.Invocation

![avatar](https://www.xs-soccer.club/picturebed/C4CA42/97/a6/f47667.png)

从这个类中获取到的信息有
* TargetServiceUniqueName - 目标serviceId
* MethodName - 方法名称
* ServiceName - 接口全限定名
* ParameterTypes - 方法入参类型数组
* CompatibleParamSignatures - 签名(为什么要数组？)
* Arguments - 方法入参值数组
* Attachments - 附件，k-v格式，可以理解为附加参数。一些定制化需求可以利用该字段（如全局traceId，鉴权字段<token>等）
* Invoker - dubbo抽象出来的服务统一处理类
* Attributes - 暂不知道干啥用的

我这个是简单版，可以用最少的字段

1. serviceId
2. methodName
3. ServiceInterfaceName
4. ParameterTypes - 方法入参类型数组——string类型，类全限定名
5. Arguments - 入参值，由string转化，最好是pojo，不然可能有问题（如httpServletRequest，InputStream这种，传不了）
6. signatures 签名

其中引申出来的问题，序列化和反序列化

对于一个pojo，其中肯定会有List\<String>、List\<BeanA>，Map<Enum, BeanB>这样的数据结构

fastjson对于泛型的支持需要测试一下。

测试结果ok，序列化、反序列化都没有问题，先用fastjson吧